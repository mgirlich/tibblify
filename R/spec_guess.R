#' Guess the `tibblify()` Specification
#'
#' @param x A nested list.
#' @param simplify_list Try to simplify lists if possible?
#'
#' @return A specification object that can used in `tibblify()`.
#' @export
#'
#' @examples
#' spec_guess(list(x = 1, y = "a"))
#' spec_guess(list(list(x = 1), list(x = 2)))
#'
#' spec_guess(gh_users)
spec_guess <- function(x) {
  if (is.data.frame(x)) {
    spec_guess_df(x)
  } else if (is.list(x)) {
    spec_guess_list(x)
  } else {
    abort(paste0(
      "Cannot guess the specification for type ",
      vctrs::vec_ptype_full(x)
    ))
  }
}


# list --------------------------------------------------------------------

#' @rdname spec_guess
#' @export
spec_guess_object_list <- function(x, simplify_list = TRUE) {
  fields <- guess_object_list_spec(x, simplify_list)

  names_to <- NULL
  if (is_named(x)) {
    names_to <- ".names"
  }
  return(spec_df(!!!fields, .names_to = names_to))
}

# list - object -----------------------------------------------------------

guess_object_list_spec <- function(x, simplify_list) {
  required <- get_required(x)

  # need to remove empty elements for `purrr::transpose()` to work...
  x <- vctrs::list_drop_empty(x)

  x_t <- purrr::transpose(unname(x), names(required))

  purrr::pmap(
    tibble::tibble(
      value = x_t,
      name = names(required),
      required = unname(required)
    ),
    guess_field_spec,
    multi = TRUE,
    simplify_list = simplify_list
  )
}

get_required <- function(x, sample_size = 10e3) {
  n <- vec_size(x)
  x <- unname(x)
  if (n > sample_size) {
    n <- sample_size
    x <- vec_slice(x, sample(n, sample_size))
  }

  all_names <- vec_c(!!!lapply(x, names), .ptype = character())
  names_count <- vec_count(all_names, "location")

  empty_loc <- lengths(x) == 0L
  if (any(empty_loc)) {
    rep_named(names_count$key, FALSE)
  } else {
    set_names(names_count$count == n, names_count$key)
  }
}

guess_field_spec <- function(value, name, required, multi,
                             simplify_list) {
  if (multi) {
    ptype_result <- get_ptype_common(value)

    # no common ptype -> it is a list of different types
    if (!ptype_result$has_common_ptype) return(tib_list(name, required))
    ptype <- ptype_result$ptype
  } else {
    ptype <- vec_ptype(value)
  }

  # now we know the shape of value
  # scalar: ptype
  # multi: list_of<ptype>

  # only `NULL` -> no information about the actual type
  if (is_null(ptype)) return(tib_unspecified(name, required))

  # TODO what if `ptype` is not a vector?
  # TODO what if `ptype` is a data frame?
  # TODO matrix
  if (!vec_is_list(ptype)) {
    # every element must be a non-list vector
    if (is_field_scalar(value, multi)) {
      return(tib_scalar(name, ptype, required))
    } else {
      return(tib_vector(name, ptype, required))
    }
  }

  value_flat <- get_flat_value(value, ptype, multi)
  if (is_object_list(value_flat)) {
    return(guess_make_tib_df(name, value_flat, required, simplify_list))
  }

  if (is_field_row(value, multi, simplify_list)) {
    fields <- guess_get_field_spec(value, multi, simplify_list)
    return(maybe_tib_row(name, fields, required))
  }

  # values2 <- vctrs::list_drop_empty(values)
  ptype_result <- get_ptype_common(value_flat)
  if (!ptype_result$has_common_ptype) return(tib_list(name, required))

  ptype <- ptype_result$ptype
  if (is_null(ptype)) return(tib_unspecified(name, required))

  if (!simplify_list) return(tib_list(name, required))

  list_of_scalars <- all(list_sizes(value_flat) == 1L)
  if (list_of_scalars) return(tib_vector(name, ptype, required, transform = make_unchop(ptype)))

  return(tib_list(name, required, transform = make_new_list_of(ptype)))
}

get_flat_value <- function(value, ptype, multi) {
  if (!multi) return(value)

  vec_unchop(value, ptype = ptype)
}

field_is_list <- function(value, ptype, object_list) {
  if (object_list) {
    vec_is_list(ptype)
  } else {
    vec_is_list(value)
  }
}

is_field_scalar <- function(value, multi) {
  if (multi) {
    # TODO not sure about this...
    all(list_sizes(value) <= 1L)
  } else {
    vec_size(value) == 1L
  }
}

is_field_row <- function(value, multi, simplify_list) {
  if (multi) {
    is_object_list(value)
  } else {
    if (can_flatten(value, simplify_list)) return(FALSE)
    is_object(value)
  }
}

can_flatten <- function(value, simplify_list) {
  if (!simplify_list) return(FALSE)

  ptype_result <- get_ptype_common(value)
  if (!ptype_result$has_common_ptype) return(FALSE)

  ptype <- ptype_result$ptype
  !is_null(ptype) && !vec_is_list(ptype)
}

guess_get_field_spec <- function(value, multi, simplify_list) {
  if (multi) {
    fields <- guess_object_list_spec(value, simplify_list)
  } else {
    fields <- guess_object_spec(value, simplify_list)
  }
}

guess_make_tib_df <- function(name, values_flat, required, simplify_list) {
  list_of_null <- all(purrr::map_lgl(values_flat, is_null))
  if (list_of_null) {
    if (is_named(values_flat) && !is_empty(values_flat)) {
        fields <- purrr::map(set_names(names(values_flat)), tib_unspecified)
        return(maybe_tib_row(name, fields, required))
      }

      return(tib_unspecified(name, required))
  }

  fields <- guess_object_list_spec(values_flat, simplify_list)
  names_to <- if (is_named(values_flat) && !is_empty(values_flat)) ".names"

  return(maybe_tib_df(name, fields, required, names_to = names_to))
}


# helpers -----------------------------------------------------------------

make_unchop <- function(ptype) {
  rlang::new_function(
    pairlist2(x = ),
    call2(sym("vec_unchop"), x = sym("x"), ptype = ptype)
  )
}

make_new_list_of <- function(ptype) {
  rlang::new_function(
    pairlist2(x = ),
    call2(sym("new_list_of"), x = sym("x"), ptype = ptype)
  )
}

maybe_tib_row <- function(name, fields, required = TRUE) {
  if (is_empty(fields)) return(tib_unspecified(name, required))

  return(tib_row(name, !!!fields, .required = required))
}

maybe_tib_df <- function(name, fields, required = TRUE, names_to = NULL) {
  if (is_empty(fields) && is_null(names_to)) {
    return(tib_unspecified(name, required))
  }

  return(tib_df(name, !!!fields, .required = required, .names_to = names_to))
}
